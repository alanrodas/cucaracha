
==================== FINAL INTERFACE ====================
2016-09-11 02:04:30.930853 UTC

interface cucar_FplgUcjuVAy8HMM9qW2uWS:Lexer 7103
  interface hash: b2bb0b4fae5df4ee7564581217d090b3
  ABI hash: c0c76bdef4f5ea74fc075c03aa27f4a0
  export-list hash: 6abafdcb263b541300780c3b79b1ab1b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 48f9f66b49f2d9913bcaef3361d0fca0
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lexer.alexGetByte
  Lexer.alexIndexInt16OffAddr
  Lexer.alexIndexInt32OffAddr
  Lexer.alexInputPrevChar
  Lexer.alexMove
  Lexer.alexScan
  Lexer.alexScanTokens
  Lexer.alexScanUser
  Lexer.alexStartPos
  Lexer.alex_accept
  Lexer.alex_action_10
  Lexer.alex_action_11
  Lexer.alex_action_12
  Lexer.alex_action_13
  Lexer.alex_action_14
  Lexer.alex_action_15
  Lexer.alex_action_16
  Lexer.alex_action_17
  Lexer.alex_action_18
  Lexer.alex_action_19
  Lexer.alex_action_2
  Lexer.alex_action_20
  Lexer.alex_action_21
  Lexer.alex_action_22
  Lexer.alex_action_23
  Lexer.alex_action_24
  Lexer.alex_action_25
  Lexer.alex_action_26
  Lexer.alex_action_27
  Lexer.alex_action_28
  Lexer.alex_action_29
  Lexer.alex_action_3
  Lexer.alex_action_30
  Lexer.alex_action_31
  Lexer.alex_action_32
  Lexer.alex_action_33
  Lexer.alex_action_34
  Lexer.alex_action_35
  Lexer.alex_action_4
  Lexer.alex_action_5
  Lexer.alex_action_6
  Lexer.alex_action_7
  Lexer.alex_action_8
  Lexer.alex_action_9
  Lexer.alex_base
  Lexer.alex_check
  Lexer.alex_deflt
  Lexer.alex_scan_tkn
  Lexer.alex_tab_size
  Lexer.alex_table
  Lexer.ignorePendingBytes
  Lexer.quickIndex
  Lexer.tokenize
  Lexer.utf8Encode
  Lexer.AlexAcc{Lexer.AlexAcc Lexer.AlexAccNone Lexer.AlexAccSkip}
  Lexer.AlexAddr{Lexer.AlexA#}
  Lexer.AlexInput
  Lexer.AlexLastAcc{Lexer.AlexLastAcc Lexer.AlexLastSkip Lexer.AlexNone}
  Lexer.AlexPosn{Lexer.AlexPn}
  Lexer.AlexReturn{Lexer.AlexEOF Lexer.AlexError Lexer.AlexSkip Lexer.AlexToken}
  Lexer.Byte
  Lexer.Token{Lexer.TokenAnd Lexer.TokenAssign Lexer.TokenBool Lexer.TokenColon Lexer.TokenComma Lexer.TokenEQ Lexer.TokenElse Lexer.TokenFalse Lexer.TokenFun Lexer.TokenGE Lexer.TokenGT Lexer.TokenHash Lexer.TokenId Lexer.TokenIf Lexer.TokenInt Lexer.TokenLBrace Lexer.TokenLBrack Lexer.TokenLE Lexer.TokenLParen Lexer.TokenLT Lexer.TokenMinus Lexer.TokenNEQ Lexer.TokenNot Lexer.TokenNum Lexer.TokenOr Lexer.TokenPlus Lexer.TokenRBrace Lexer.TokenRBrack Lexer.TokenRParen Lexer.TokenReturn Lexer.TokenTimes Lexer.TokenTrue Lexer.TokenVec Lexer.TokenWhile}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 ghc-prim-0.4.0.0 integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
import  -/  array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA:Data.Array 6e22602c1cc5e362609f0924a7c0a209
import  -/  array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA:Data.Array.Base a0576aaf9a801948417a257cfc0c6084
import  -/  base-4.8.2.0:Data.Bits 87551525e7ef366d0fc4cad44e8b1bfc
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Arr 70f35e6bfbc61995e045edb612354887
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Exts 7bdf420b67c4b8c9ccc9ea593e90bb92
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type 371e90fe753f08ddedf0d2657a9ef5c4
addDependentFile "/Users/alanrodas/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/include/ghcversion.h"
addDependentFile "src/Lexer.x"
addDependentFile "/Users/alanrodas/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/include/ghcconfig.h"
addDependentFile "/Users/alanrodas/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/include/ghcplatform.h"
addDependentFile "/Users/alanrodas/.stack/programs/x86_64-osx/ghc-7.10.3/lib/ghc-7.10.3/include/ghcautoconf.h"
addDependentFile ".stack-work/dist/x86_64-osx/Cabal-1.22.5.0/build/autogen/cabal_macros.h"
368a6a10a67b0daaf57d627d08f85454
  $fEqAlexPosn :: GHC.Classes.Eq Lexer.AlexPosn
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.AlexPosn Lexer.$fEqAlexPosn_$c== Lexer.$fEqAlexPosn_$c/= -}
368a6a10a67b0daaf57d627d08f85454
  $fEqAlexPosn_$c/= ::
    Lexer.AlexPosn -> Lexer.AlexPosn -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lexer.AlexPosn b :: Lexer.AlexPosn ->
                 case a of wild { Lexer.AlexPn dt dt1 dt2 ->
                 case b of wild1 { Lexer.AlexPn dt3 dt4 dt5 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# dt dt3) of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# dt1 dt4) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# dt2 dt5) of wild4 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } } } }) -}
368a6a10a67b0daaf57d627d08f85454
  $fEqAlexPosn_$c== ::
    Lexer.AlexPosn -> Lexer.AlexPosn -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U)><S,1*U(U,U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Lexer.AlexPosn ds1 :: Lexer.AlexPosn ->
                 case ds of wild { Lexer.AlexPn dt dt1 dt2 ->
                 case ds1 of wild1 { Lexer.AlexPn dt3 dt4 dt5 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# dt dt3) of wild2 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# dt1 dt4) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# dt2 dt5) } } } }) -}
b0236eae71a537521a71ca6a68b7aadb
  $fEqToken :: GHC.Classes.Eq Lexer.Token
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.Token Lexer.$fEqToken_$c== Lexer.$fEqToken_$c/= -}
b0236eae71a537521a71ca6a68b7aadb
  $fEqToken_$c/= :: Lexer.Token -> Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Lexer.Token b :: Lexer.Token ->
                 case Lexer.$fEqToken_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b0236eae71a537521a71ca6a68b7aadb
  $fEqToken_$c== :: Lexer.Token -> Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
d14dee672e0ad25b29dd72b8e739a475
  $fFunctorAlexLastAcc :: GHC.Base.Functor Lexer.AlexLastAcc
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.AlexLastAcc
                  Lexer.$fFunctorAlexLastAcc_$cfmap
                  Lexer.$fFunctorAlexLastAcc_$c<$ -}
d14dee672e0ad25b29dd72b8e739a475
  $fFunctorAlexLastAcc_$c<$ ::
    a -> Lexer.AlexLastAcc b -> Lexer.AlexLastAcc a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b eta :: a ds :: Lexer.AlexLastAcc b ->
                 case ds of wild {
                   Lexer.AlexNone -> Lexer.AlexNone @ a
                   Lexer.AlexLastAcc x y dt -> Lexer.AlexLastAcc @ a eta y dt
                   Lexer.AlexLastSkip x dt -> Lexer.AlexLastSkip @ a x dt }) -}
d14dee672e0ad25b29dd72b8e739a475
  $fFunctorAlexLastAcc_$cfmap ::
    (a -> b) -> Lexer.AlexLastAcc a -> Lexer.AlexLastAcc b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b ds :: a -> b ds1 :: Lexer.AlexLastAcc a ->
                 case ds1 of wild {
                   Lexer.AlexNone -> Lexer.AlexNone @ b
                   Lexer.AlexLastAcc x y dt -> Lexer.AlexLastAcc @ b (ds x) y dt
                   Lexer.AlexLastSkip x dt -> Lexer.AlexLastSkip @ b x dt }) -}
368a6a10a67b0daaf57d627d08f85454
  $fShowAlexPosn :: GHC.Show.Show Lexer.AlexPosn
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.AlexPosn
                  Lexer.$fShowAlexPosn_$cshowsPrec
                  Lexer.$fShowAlexPosn_$cshow
                  Lexer.$fShowAlexPosn_$cshowList -}
368a6a10a67b0daaf57d627d08f85454
  $fShowAlexPosn1 :: Lexer.AlexPosn -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Lexer.AlexPosn w1 :: GHC.Base.String ->
                 case w of ww { Lexer.AlexPn ww1 ww2 ww3 ->
                 Lexer.$w$cshowsPrec 0 ww1 ww2 ww3 w1 }) -}
0fedc918191b13f0026802d901c6d8a4
  $fShowAlexPosn2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AlexPn "#) -}
368a6a10a67b0daaf57d627d08f85454
  $fShowAlexPosn_$cshow :: Lexer.AlexPosn -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lexer.AlexPosn ->
                 Lexer.$fShowAlexPosn_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
368a6a10a67b0daaf57d627d08f85454
  $fShowAlexPosn_$cshowList :: [Lexer.AlexPosn] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lexer.AlexPosn
                   Lexer.$fShowAlexPosn1) -}
368a6a10a67b0daaf57d627d08f85454
  $fShowAlexPosn_$cshowsPrec ::
    GHC.Types.Int -> Lexer.AlexPosn -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(U,U,U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Lexer.AlexPosn w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lexer.AlexPn ww3 ww4 ww5 ->
                 Lexer.$w$cshowsPrec ww1 ww3 ww4 ww5 w2 } }) -}
b0236eae71a537521a71ca6a68b7aadb
  $fShowToken :: GHC.Show.Show Lexer.Token
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.Token
                  Lexer.$fShowToken_$cshowsPrec
                  Lexer.$fShowToken_$cshow
                  Lexer.$fShowToken_$cshowList -}
b0236eae71a537521a71ca6a68b7aadb
  $fShowToken1 :: Lexer.Token -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Lexer.Token w1 :: GHC.Base.String ->
                 Lexer.$w$cshowsPrec1 0 w w1) -}
b0236eae71a537521a71ca6a68b7aadb
  $fShowToken_$cshow :: Lexer.Token -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Lexer.Token ->
                 Lexer.$fShowToken_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b0236eae71a537521a71ca6a68b7aadb
  $fShowToken_$cshowList :: [Lexer.Token] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lexer.Token
                   Lexer.$fShowToken1) -}
b0236eae71a537521a71ca6a68b7aadb
  $fShowToken_$cshowsPrec ::
    GHC.Types.Int -> Lexer.Token -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Lexer.Token w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Lexer.$w$cshowsPrec1 ww1 w1 w2 }) -}
d251b78b045ca4af1bb64b3f119a733c
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Lexer.$fShowAlexPosn2
                       (case GHC.Show.$wshowSignedInt
                               11
                               ww1
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.showSpace1
                                  (case GHC.Show.$wshowSignedInt
                                          11
                                          ww2
                                          (GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.showSpace1
                                             (case GHC.Show.$wshowSignedInt
                                                     11
                                                     ww3
                                                     x of ww4 { (#,#) ww5 ww6 ->
                                              GHC.Types.:
                                                @ GHC.Types.Char
                                                ww5
                                                ww6 })) of ww4 { (#,#) ww5 ww6 ->
                                   GHC.Types.:
                                     @ GHC.Types.Char
                                     ww5
                                     ww6 })) of ww4 { (#,#) ww5 ww6 ->
                        GHC.Types.: @ GHC.Types.Char ww5 ww6 })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
b0236eae71a537521a71ca6a68b7aadb
  $w$cshowsPrec1 ::
    GHC.Prim.Int# -> Lexer.Token -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0] -}
a964f76cfb469110dfe3f4cc82bbad65
  $walexGetByte ::
    Lexer.AlexPosn
    -> GHC.Types.Char
    -> [Lexer.Byte]
    -> GHC.Base.String
    -> GHC.Base.Maybe (Lexer.Byte, Lexer.AlexInput)
  {- Arity: 4, Strictness: <L,U(U,U,U)><L,U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: Lexer.AlexPosn
                   ww1 :: GHC.Types.Char
                   ww2 :: [Lexer.Byte]
                   ww3 :: GHC.Base.String ->
                 case ww2 of wild {
                   []
                   -> case ww3 of wild1 {
                        [] -> GHC.Base.Nothing @ (Lexer.Byte, Lexer.AlexInput)
                        : c s
                        -> case ww of wild2 { Lexer.AlexPn dt dt1 dt2 ->
                           case c of wild3 { GHC.Types.C# ds ->
                           case case ds of ds1 {
                                  DEFAULT -> Lexer.AlexPn (GHC.Prim.+# dt 1) dt1 (GHC.Prim.+# dt2 1)
                                  '\t'
                                  -> case GHC.Classes.divInt#
                                            (GHC.Prim.-# (GHC.Prim.+# dt2 8) 1)
                                            8 of ww4 { DEFAULT ->
                                     Lexer.AlexPn
                                       (GHC.Prim.+# dt 1)
                                       dt1
                                       (GHC.Prim.+# (GHC.Prim.*# ww4 8) 1) }
                                  '\n'
                                  -> Lexer.AlexPn
                                       (GHC.Prim.+# dt 1)
                                       (GHC.Prim.+# dt1 1)
                                       1 } of p' { Lexer.AlexPn ipv ipv1 ipv2 ->
                           let {
                             ds1 :: (GHC.Word.Word8, [GHC.Word.Word8])
                             = let {
                                 ww4 :: GHC.Prim.Int# = GHC.Prim.ord# ds
                               } in
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<=# ww4 127) of wild4 {
                                 GHC.Types.False
                                 -> case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.<=# ww4 2047) of wild5 {
                                      GHC.Types.False
                                      -> case GHC.Prim.tagToEnum#
                                                @ GHC.Types.Bool
                                                (GHC.Prim.<=# ww4 65535) of wild6 {
                                           GHC.Types.False
                                           -> case GHC.Base.map
                                                     @ GHC.Types.Int
                                                     @ GHC.Word.Word8
                                                     Lexer.alexGetByte2
                                                     (GHC.Types.:
                                                        @ GHC.Types.Int
                                                        (GHC.Types.I#
                                                           (GHC.Prim.+#
                                                              240
                                                              (GHC.Prim.uncheckedIShiftRA# ww4 18)))
                                                        (GHC.Types.:
                                                           @ GHC.Types.Int
                                                           (GHC.Types.I#
                                                              (GHC.Prim.+#
                                                                 128
                                                                 (GHC.Prim.andI#
                                                                    (GHC.Prim.uncheckedIShiftRA#
                                                                       ww4
                                                                       12)
                                                                    63)))
                                                           (GHC.Types.:
                                                              @ GHC.Types.Int
                                                              (GHC.Types.I#
                                                                 (GHC.Prim.+#
                                                                    128
                                                                    (GHC.Prim.andI#
                                                                       (GHC.Prim.uncheckedIShiftRA#
                                                                          ww4
                                                                          6)
                                                                       63)))
                                                              (GHC.Types.:
                                                                 @ GHC.Types.Int
                                                                 (GHC.Types.I#
                                                                    (GHC.Prim.+#
                                                                       128
                                                                       (GHC.Prim.andI# ww4 63)))
                                                                 (GHC.Types.[]
                                                                    @ GHC.Types.Int))))) of wild7 {
                                                [] -> Lexer.alexGetByte1 : b bs -> (b, bs) }
                                           GHC.Types.True
                                           -> case GHC.Base.map
                                                     @ GHC.Types.Int
                                                     @ GHC.Word.Word8
                                                     Lexer.alexGetByte2
                                                     (GHC.Types.:
                                                        @ GHC.Types.Int
                                                        (GHC.Types.I#
                                                           (GHC.Prim.+#
                                                              224
                                                              (GHC.Prim.uncheckedIShiftRA# ww4 12)))
                                                        (GHC.Types.:
                                                           @ GHC.Types.Int
                                                           (GHC.Types.I#
                                                              (GHC.Prim.+#
                                                                 128
                                                                 (GHC.Prim.andI#
                                                                    (GHC.Prim.uncheckedIShiftRA#
                                                                       ww4
                                                                       6)
                                                                    63)))
                                                           (GHC.Types.:
                                                              @ GHC.Types.Int
                                                              (GHC.Types.I#
                                                                 (GHC.Prim.+#
                                                                    128
                                                                    (GHC.Prim.andI# ww4 63)))
                                                              (GHC.Types.[]
                                                                 @ GHC.Types.Int)))) of wild7 {
                                                [] -> Lexer.alexGetByte1 : b bs -> (b, bs) } }
                                      GHC.Types.True
                                      -> case GHC.Base.map
                                                @ GHC.Types.Int
                                                @ GHC.Word.Word8
                                                Lexer.alexGetByte2
                                                (GHC.Types.:
                                                   @ GHC.Types.Int
                                                   (GHC.Types.I#
                                                      (GHC.Prim.+#
                                                         192
                                                         (GHC.Prim.uncheckedIShiftRA# ww4 6)))
                                                   (GHC.Types.:
                                                      @ GHC.Types.Int
                                                      (GHC.Types.I#
                                                         (GHC.Prim.+# 128 (GHC.Prim.andI# ww4 63)))
                                                      (GHC.Types.[] @ GHC.Types.Int))) of wild6 {
                                           [] -> Lexer.alexGetByte1 : b bs -> (b, bs) } }
                                 GHC.Types.True
                                 -> case GHC.Base.map
                                           @ GHC.Types.Int
                                           @ GHC.Word.Word8
                                           Lexer.alexGetByte2
                                           (GHC.Types.:
                                              @ GHC.Types.Int
                                              (GHC.Types.I# ww4)
                                              (GHC.Types.[] @ GHC.Types.Int)) of wild5 {
                                      [] -> Lexer.alexGetByte1 : b bs -> (b, bs) } }
                           } in
                           GHC.Base.Just
                             @ (Lexer.Byte, Lexer.AlexInput)
                             (case ds1 of ds2 { (,) b bs -> b },
                              (p', wild3, case ds1 of ds2 { (,) b bs -> bs }, s)) } } } }
                   : b bs
                   -> GHC.Base.Just
                        @ (Lexer.Byte, Lexer.AlexInput)
                        (b, (ww, ww1, bs, ww3)) }) -}
a1ffb97733807b3b911aa67b4d97082a
  $walexScanUser ::
    Lexer.AlexPosn
    -> GHC.Types.Char
    -> [Lexer.Byte]
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> Lexer.AlexReturn
         (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
  {- Arity: 5, Strictness: <L,U(U,U,U)><L,U><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ t
                   ww :: Lexer.AlexPosn
                   ww1 :: GHC.Types.Char
                   ww2 :: [Lexer.Byte]
                   ww3 :: GHC.Base.String
                   ww4 :: GHC.Prim.Int# ->
                 case Lexer.$walex_scan_tkn
                        @ t
                        @ Lexer.AlexInput
                        0
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        (Lexer.AlexNone
                           @ (Lexer.AlexPosn
                              -> GHC.Base.String -> Lexer.Token)) of ww5 { (#,#) ww6 ww7 ->
                 case ww6 of wild {
                   Lexer.AlexNone
                   -> case Lexer.$walexGetByte ww ww1 ww2 ww3 of wild1 {
                        GHC.Base.Nothing
                        -> Lexer.AlexEOF
                             @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                        GHC.Base.Just ds
                        -> Lexer.$WAlexError
                             @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                             ww7 }
                   Lexer.AlexLastAcc k input''' dt
                   -> Lexer.AlexToken
                        @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                        input'''
                        dt
                        k
                   Lexer.AlexLastSkip input'' dt
                   -> Lexer.AlexSkip
                        @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                        input''
                        dt } }) -}
62a744a66199956e3680c41ffaf02057
  $walex_scan_tkn ::
    GHC.Prim.Int#
    -> Lexer.AlexPosn
    -> GHC.Types.Char
    -> [Lexer.Byte]
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> Lexer.AlexLastAcc
         (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
    -> (# Lexer.AlexLastAcc
            (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token),
          Lexer.AlexInput #)
  {- Arity: 7,
     Strictness: <L,U><L,U(U,U,U)><L,U><S,U><L,U><L,U><L,1*U>,
     Inline: [0] -}
cdec28d83d2c70af0259b37536621e1b
  $wgo ::
    Lexer.AlexPosn
    -> GHC.Types.Char
    -> [Lexer.Byte]
    -> GHC.Base.String
    -> [Lexer.Token]
  {- Arity: 4, Strictness: <L,U(U,U,U)><L,U><S,U><L,U>,
     Inline: [0] -}
258a38d29c969a84a2566cf24b789d9f
  type role AlexAcc representational phantom
  data AlexAcc a user = AlexAccNone | AlexAcc a | AlexAccSkip
    Promotable
ddc50fc9dc2fb82b1e36dcae54be7e34
  data AlexAddr = AlexA# GHC.Prim.Addr#
88d6f9fa87ede8c67e8484eb407c5da1
  type AlexInput =
    (Lexer.AlexPosn, GHC.Types.Char, [Lexer.Byte], GHC.Base.String)
d14dee672e0ad25b29dd72b8e739a475
  data AlexLastAcc a
    = AlexNone
    | AlexLastAcc a !Lexer.AlexInput {-# UNPACK #-}GHC.Types.Int
    | AlexLastSkip !Lexer.AlexInput {-# UNPACK #-}GHC.Types.Int
368a6a10a67b0daaf57d627d08f85454
  data AlexPosn
    = AlexPn {-# UNPACK #-}GHC.Types.Int
             {-# UNPACK #-}GHC.Types.Int
             {-# UNPACK #-}GHC.Types.Int
1c88cb7103892fddc47083b2e23c963c
  data AlexReturn a
    = AlexEOF
    | AlexError !Lexer.AlexInput
    | AlexSkip !Lexer.AlexInput {-# UNPACK #-}GHC.Types.Int
    | AlexToken !Lexer.AlexInput {-# UNPACK #-}GHC.Types.Int a
92c3763a2bfa01142d4f83cee1a7f2c9
  type Byte = GHC.Word.Word8
b0236eae71a537521a71ca6a68b7aadb
  data Token
    = TokenLParen Lexer.AlexPosn
    | TokenRParen Lexer.AlexPosn
    | TokenLBrack Lexer.AlexPosn
    | TokenRBrack Lexer.AlexPosn
    | TokenLBrace Lexer.AlexPosn
    | TokenRBrace Lexer.AlexPosn
    | TokenAssign Lexer.AlexPosn
    | TokenColon Lexer.AlexPosn
    | TokenComma Lexer.AlexPosn
    | TokenHash Lexer.AlexPosn
    | TokenGE Lexer.AlexPosn
    | TokenLE Lexer.AlexPosn
    | TokenGT Lexer.AlexPosn
    | TokenLT Lexer.AlexPosn
    | TokenEQ Lexer.AlexPosn
    | TokenNEQ Lexer.AlexPosn
    | TokenPlus Lexer.AlexPosn
    | TokenMinus Lexer.AlexPosn
    | TokenTimes Lexer.AlexPosn
    | TokenBool Lexer.AlexPosn
    | TokenInt Lexer.AlexPosn
    | TokenVec Lexer.AlexPosn
    | TokenTrue Lexer.AlexPosn
    | TokenFalse Lexer.AlexPosn
    | TokenNot Lexer.AlexPosn
    | TokenAnd Lexer.AlexPosn
    | TokenOr Lexer.AlexPosn
    | TokenFun Lexer.AlexPosn
    | TokenIf Lexer.AlexPosn
    | TokenElse Lexer.AlexPosn
    | TokenWhile Lexer.AlexPosn
    | TokenReturn Lexer.AlexPosn
    | TokenId (Lexer.AlexPosn, GHC.Base.String)
    | TokenNum (Lexer.AlexPosn, GHC.Integer.Type.Integer)
aa5479ca496c01d0c9339a7a4bd5f79c
  alexGetByte ::
    Lexer.AlexInput -> GHC.Base.Maybe (Lexer.Byte, Lexer.AlexInput)
  {- Arity: 1, Strictness: <S(LLSL),1*U(U(U,U,U),U,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Lexer.AlexInput ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 Lexer.$walexGetByte ww1 ww2 ww3 ww4 }) -}
73ed93f5d564fb710e9b11bed33d1daf
  alexGetByte1 :: (GHC.Word.Word8, [GHC.Word.Word8])
  {- Strictness: b -}
a914e9892953f270cbbf3bd5096640cd
  alexGetByte2 :: GHC.Types.Int -> GHC.Word.Word8
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Types.Int ->
                 case x of wild { GHC.Types.I# x# ->
                 GHC.Word.W8# (GHC.Prim.narrow8Word# (GHC.Prim.int2Word# x#)) }) -}
f3e773004c5511ceeb8c7ee0cc2b26d6
  alexIndexInt16OffAddr ::
    Lexer.AlexAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ ds :: Lexer.AlexAddr off :: GHC.Prim.Int# ->
                 case ds of wild { Lexer.AlexA# arr ->
                 GHC.Prim.indexInt16OffAddr# arr off }) -}
fad5ec3a4fd26d2f372cd59d2fe9b472
  alexIndexInt32OffAddr ::
    Lexer.AlexAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ ds :: Lexer.AlexAddr off :: GHC.Prim.Int# ->
                 case ds of wild { Lexer.AlexA# arr ->
                 GHC.Prim.indexInt32OffAddr# arr off }) -}
097eea9e7d175ead5367b7a806be514e
  alexInputPrevChar :: Lexer.AlexInput -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U(U),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (Lexer.AlexPosn,
                          GHC.Types.Char,
                          [Lexer.Byte],
                          GHC.Base.String) ->
                 case ds of wild { (,,,) p c bs s -> c }) -}
5d739cd1ac773305f2fb0f540429eec0
  alexMove :: Lexer.AlexPosn -> GHC.Types.Char -> Lexer.AlexPosn
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U,U)><S(S),1*U(1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Lexer.AlexPosn w1 :: GHC.Types.Char ->
                 case w of ww { Lexer.AlexPn ww1 ww2 ww3 ->
                 case w1 of ww4 { GHC.Types.C# ww5 ->
                 case ww5 of ds {
                   DEFAULT -> Lexer.AlexPn (GHC.Prim.+# ww1 1) ww2 (GHC.Prim.+# ww3 1)
                   '\t'
                   -> case GHC.Classes.divInt#
                             (GHC.Prim.-# (GHC.Prim.+# ww3 8) 1)
                             8 of ww6 { DEFAULT ->
                      Lexer.AlexPn
                        (GHC.Prim.+# ww1 1)
                        ww2
                        (GHC.Prim.+# (GHC.Prim.*# ww6 8) 1) }
                   '\n'
                   -> Lexer.AlexPn (GHC.Prim.+# ww1 1) (GHC.Prim.+# ww2 1) 1 } } }) -}
2763ee14894aace7196c22516ba1f6e9
  alexScan ::
    Lexer.AlexInput
    -> GHC.Types.Int
    -> Lexer.AlexReturn
         (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
  {- Arity: 2, Strictness: <S(LLSL),U(U(U,U,U),U,U,U)><S,1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ input :: Lexer.AlexInput ds :: GHC.Types.Int ->
                 case ds of wild { GHC.Types.I# sc ->
                 Lexer.alexScanUser
                   @ GHC.Prim.Any
                   (GHC.Err.undefined @ GHC.Prim.Any)
                   input
                   (GHC.Types.I# sc) }) -}
00bd53f55c4869dbbde22a51666eaeb9
  alexScanTokens :: GHC.Base.String -> [Lexer.Token]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ str :: GHC.Base.String ->
                 Lexer.alexScanTokens_go
                   (Lexer.alexStartPos,
                    Lexer.alexScanTokens1,
                    GHC.Types.[] @ Lexer.Byte,
                    str)) -}
082cf2cace0d743a9a37edce113975bd
  alexScanTokens1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '\n') -}
d8ab6bbdaee9ede3f5e0b847a3327779
  alexScanTokens_go ::
    (Lexer.AlexPosn, GHC.Types.Char, [Lexer.Byte], GHC.Base.String)
    -> [Lexer.Token]
  {- Arity: 1, Strictness: <S(LLSL),1*U(U(U,U,U),U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: (Lexer.AlexPosn,
                         GHC.Types.Char,
                         [Lexer.Byte],
                         GHC.Base.String) ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 Lexer.$wgo ww1 ww2 ww3 ww4 }) -}
ff239e392d977e7567c1d1e504e091e0
  alexScanUser ::
    t
    -> Lexer.AlexInput
    -> GHC.Types.Int
    -> Lexer.AlexReturn
         (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
  {- Arity: 3,
     Strictness: <L,A><S(LLSL),U(U(U,U,U),U,U,U)><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ t w :: t w1 :: Lexer.AlexInput w2 :: GHC.Types.Int ->
                 case w1 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 case w2 of ww5 { GHC.Types.I# ww6 ->
                 Lexer.$walexScanUser @ t ww1 ww2 ww3 ww4 ww6 } }) -}
62ce1702ce26e40117b4bc2478c5e2c7
  alexStartPos :: Lexer.AlexPosn
  {- HasNoCafRefs, Strictness: m, Unfolding: (Lexer.AlexPn 0 1 1) -}
fca42a714a73c6fa4e80595d43770ab0
  alex_accept ::
    GHC.Arr.Array
      GHC.Types.Int
      (Lexer.AlexAcc
         (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
  {- Unfolding: (\ @ user ->
                 GHC.ST.runSTRep
                   @ (GHC.Arr.Array
                        GHC.Types.Int
                        (Lexer.AlexAcc
                           (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user))
                   (Lexer.alex_accept1 @ user)) -}
e80b7fa677358b0806c15c5e663d9a58
  alex_accept1 ::
    GHC.Prim.State# s
    -> (# GHC.Prim.State# s,
          GHC.Arr.Array
            GHC.Types.Int
            (Lexer.AlexAcc
               (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user) #)
  {- Arity: 1,
     Unfolding: (\ @ user @ s s1# :: GHC.Prim.State# s[OneShot] ->
                 case GHC.Prim.newArray#
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        @ s
                        83
                        (GHC.Arr.arrEleBottom
                           @ (Lexer.AlexAcc
                                (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user))
                        s1# of ds1 { (#,#) ipv ipv1 ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        0
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        ipv of s4# { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        1
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4# of s4#1 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        2
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#1 of s4#2 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        3
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#2 of s4#3 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        4
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#3 of s4#4 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        5
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#4 of s4#5 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        6
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#5 of s4#6 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        7
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#6 of s4#7 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        8
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#7 of s4#8 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        9
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#8 of s4#9 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        10
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#9 of s4#10 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        11
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#10 of s4#11 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        12
                        (Lexer.AlexAccNone
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#11 of s4#12 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        13
                        (Lexer.AlexAccSkip
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#12 of s4#13 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        14
                        (Lexer.AlexAccSkip
                           @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                           @ user)
                        s4#13 of s4#14 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        15
                        (Lexer.alex_accept37 @ user)
                        s4#14 of s4#15 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        16
                        (Lexer.alex_accept36 @ user)
                        s4#15 of s4#16 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        17
                        (Lexer.alex_accept35 @ user)
                        s4#16 of s4#17 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        18
                        (Lexer.alex_accept34 @ user)
                        s4#17 of s4#18 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        19
                        (Lexer.alex_accept33 @ user)
                        s4#18 of s4#19 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        20
                        (Lexer.alex_accept32 @ user)
                        s4#19 of s4#20 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        21
                        (Lexer.alex_accept31 @ user)
                        s4#20 of s4#21 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        22
                        (Lexer.alex_accept30 @ user)
                        s4#21 of s4#22 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        23
                        (Lexer.alex_accept29 @ user)
                        s4#22 of s4#23 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        24
                        (Lexer.alex_accept28 @ user)
                        s4#23 of s4#24 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        25
                        (Lexer.alex_accept27 @ user)
                        s4#24 of s4#25 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        26
                        (Lexer.alex_accept26 @ user)
                        s4#25 of s4#26 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        27
                        (Lexer.alex_accept25 @ user)
                        s4#26 of s4#27 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        28
                        (Lexer.alex_accept24 @ user)
                        s4#27 of s4#28 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        29
                        (Lexer.alex_accept23 @ user)
                        s4#28 of s4#29 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        30
                        (Lexer.alex_accept22 @ user)
                        s4#29 of s4#30 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        31
                        (Lexer.alex_accept21 @ user)
                        s4#30 of s4#31 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        32
                        (Lexer.alex_accept20 @ user)
                        s4#31 of s4#32 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        33
                        (Lexer.alex_accept19 @ user)
                        s4#32 of s4#33 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        34
                        (Lexer.alex_accept18 @ user)
                        s4#33 of s4#34 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        35
                        (Lexer.alex_accept17 @ user)
                        s4#34 of s4#35 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        36
                        (Lexer.alex_accept16 @ user)
                        s4#35 of s4#36 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        37
                        (Lexer.alex_accept15 @ user)
                        s4#36 of s4#37 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        38
                        (Lexer.alex_accept14 @ user)
                        s4#37 of s4#38 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        39
                        (Lexer.alex_accept13 @ user)
                        s4#38 of s4#39 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        40
                        (Lexer.alex_accept12 @ user)
                        s4#39 of s4#40 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        41
                        (Lexer.alex_accept11 @ user)
                        s4#40 of s4#41 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        42
                        (Lexer.alex_accept10 @ user)
                        s4#41 of s4#42 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        43
                        (Lexer.alex_accept9 @ user)
                        s4#42 of s4#43 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        44
                        (Lexer.alex_accept8 @ user)
                        s4#43 of s4#44 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        45
                        (Lexer.alex_accept7 @ user)
                        s4#44 of s4#45 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        46
                        (Lexer.alex_accept6 @ user)
                        s4#45 of s4#46 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        47
                        (Lexer.alex_accept5 @ user)
                        s4#46 of s4#47 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        48
                        (Lexer.alex_accept5 @ user)
                        s4#47 of s4#48 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        49
                        (Lexer.alex_accept5 @ user)
                        s4#48 of s4#49 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        50
                        (Lexer.alex_accept5 @ user)
                        s4#49 of s4#50 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        51
                        (Lexer.alex_accept5 @ user)
                        s4#50 of s4#51 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        52
                        (Lexer.alex_accept5 @ user)
                        s4#51 of s4#52 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        53
                        (Lexer.alex_accept5 @ user)
                        s4#52 of s4#53 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        54
                        (Lexer.alex_accept5 @ user)
                        s4#53 of s4#54 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        55
                        (Lexer.alex_accept5 @ user)
                        s4#54 of s4#55 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        56
                        (Lexer.alex_accept5 @ user)
                        s4#55 of s4#56 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        57
                        (Lexer.alex_accept5 @ user)
                        s4#56 of s4#57 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        58
                        (Lexer.alex_accept5 @ user)
                        s4#57 of s4#58 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        59
                        (Lexer.alex_accept5 @ user)
                        s4#58 of s4#59 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        60
                        (Lexer.alex_accept5 @ user)
                        s4#59 of s4#60 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        61
                        (Lexer.alex_accept5 @ user)
                        s4#60 of s4#61 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        62
                        (Lexer.alex_accept5 @ user)
                        s4#61 of s4#62 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        63
                        (Lexer.alex_accept5 @ user)
                        s4#62 of s4#63 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        64
                        (Lexer.alex_accept5 @ user)
                        s4#63 of s4#64 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        65
                        (Lexer.alex_accept5 @ user)
                        s4#64 of s4#65 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        66
                        (Lexer.alex_accept5 @ user)
                        s4#65 of s4#66 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        67
                        (Lexer.alex_accept5 @ user)
                        s4#66 of s4#67 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        68
                        (Lexer.alex_accept5 @ user)
                        s4#67 of s4#68 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        69
                        (Lexer.alex_accept5 @ user)
                        s4#68 of s4#69 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        70
                        (Lexer.alex_accept5 @ user)
                        s4#69 of s4#70 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        71
                        (Lexer.alex_accept5 @ user)
                        s4#70 of s4#71 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        72
                        (Lexer.alex_accept5 @ user)
                        s4#71 of s4#72 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        73
                        (Lexer.alex_accept5 @ user)
                        s4#72 of s4#73 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        74
                        (Lexer.alex_accept5 @ user)
                        s4#73 of s4#74 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        75
                        (Lexer.alex_accept5 @ user)
                        s4#74 of s4#75 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        76
                        (Lexer.alex_accept5 @ user)
                        s4#75 of s4#76 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        77
                        (Lexer.alex_accept5 @ user)
                        s4#76 of s4#77 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        78
                        (Lexer.alex_accept5 @ user)
                        s4#77 of s4#78 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        79
                        (Lexer.alex_accept5 @ user)
                        s4#78 of s4#79 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        80
                        (Lexer.alex_accept5 @ user)
                        s4#79 of s4#80 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        81
                        (Lexer.alex_accept5 @ user)
                        s4#80 of s4#81 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        82
                        (Lexer.alex_accept4 @ user)
                        s4#81 of s4#82 { DEFAULT ->
                 case GHC.Prim.unsafeFreezeArray#
                        @ s
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                        ipv1
                        s4#82 of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    GHC.Arr.Array
                      @ GHC.Types.Int
                      @ (Lexer.AlexAcc
                           (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user)
                      Lexer.alex_accept3
                      Lexer.alex_accept2
                      83
                      ipv3 #) } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } } }) -}
a0928d3f6bb57c8b395292e03583f7b9
  alex_accept10 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_29 @ GHC.Base.String)) -}
5645f967bf9b2176fbc23c182638aa19
  alex_accept11 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_28 @ GHC.Base.String)) -}
73f084a0d97bb9a507eddc12093a2a86
  alex_accept12 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_27 @ GHC.Base.String)) -}
bdd977e883ea2a442af2a01faa0da148
  alex_accept13 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_26 @ GHC.Base.String)) -}
086a3d26c3133745276e79ad4f345a27
  alex_accept14 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_25 @ GHC.Base.String)) -}
200bd7b76a73de72fe6edde886e78098
  alex_accept15 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_24 @ GHC.Base.String)) -}
34368f1106f2c57df872ee1ba8a50eef
  alex_accept16 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_23 @ GHC.Base.String)) -}
cfce0d2a65d70d98dab83e1f7443d427
  alex_accept17 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_22 @ GHC.Base.String)) -}
feb8e046bbe0d94c4e30ffdd68d973ab
  alex_accept18 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_21 @ GHC.Base.String)) -}
758ff1d972184d4ed1fb47f42206b478
  alex_accept19 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_20 @ GHC.Base.String)) -}
682abf1b6ffc82c09c13a1271173f692
  alex_accept2 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 82) -}
8d697feb5a09d71671ef443970d1d797
  alex_accept20 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_19 @ GHC.Base.String)) -}
12d831b7f81b88df9a7f23f2e1f87b4b
  alex_accept21 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_18 @ GHC.Base.String)) -}
56f1233f5eb2272bc3dfbc0818eeb2bb
  alex_accept22 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_17 @ GHC.Base.String)) -}
cf02dc48b850bc9ee73ef032ab4d1c15
  alex_accept23 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_16 @ GHC.Base.String)) -}
d14c6a06a0fc582d4f32197a263c2831
  alex_accept24 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_15 @ GHC.Base.String)) -}
28f2f89a8604cc8cbdc5b29a5d9dbee2
  alex_accept25 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_14 @ GHC.Base.String)) -}
3b45f050a4b6c614858e5072fb70f5fa
  alex_accept26 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_13 @ GHC.Base.String)) -}
73f5920b6ea76a0fad235aba1dd47fa6
  alex_accept27 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_12 @ GHC.Base.String)) -}
549f26b0c379d91dcb4f9ae695570f3f
  alex_accept28 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_11 @ GHC.Base.String)) -}
3e773b56a6466b27f840c5d85a6da1a5
  alex_accept29 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_10 @ GHC.Base.String)) -}
b008873527319cc69ccfdac1296140a3
  alex_accept3 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0) -}
d34f114f841a19b5655d36ebc2d97b16
  alex_accept30 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_9 @ GHC.Base.String)) -}
f7b51e371505d84ff88b01a222b8b3a8
  alex_accept31 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_8 @ GHC.Base.String)) -}
0329c8880a66799d0554480f7efe632a
  alex_accept32 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_7 @ GHC.Base.String)) -}
ab194df67c5d912529d2b11ff396df1b
  alex_accept33 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_6 @ GHC.Base.String)) -}
574d94dfe3921964bf7df38e1d964a62
  alex_accept34 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_5 @ GHC.Base.String)) -}
c473218d798923f8b5be65270b882365
  alex_accept35 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_4 @ GHC.Base.String)) -}
d467cd87212b4d4867b7502a050804e3
  alex_accept36 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_3 @ GHC.Base.String)) -}
283712bc8a39d98c989d7b261d393b01
  alex_accept37 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_2 @ GHC.Base.String)) -}
2aae4b64ad96e3cb1a84b099cf61bfb4
  alex_accept4 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   Lexer.alex_action_35) -}
fe779bdaa67677f3f87398b403933f3a
  alex_accept5 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   Lexer.alex_action_34) -}
8d4ae3f49d5c9f841014c49ecebb0413
  alex_accept6 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_33 @ GHC.Base.String)) -}
387b13d5e6edf76f0f48f4a7bbf7fe6d
  alex_accept7 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_32 @ GHC.Base.String)) -}
3571db1fd412fa09bb70843134eba035
  alex_accept8 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_31 @ GHC.Base.String)) -}
83e0102c1215589b53701cf79111a89c
  alex_accept9 ::
    Lexer.AlexAcc
      (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc
                   @ (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
                   @ user
                   (Lexer.alex_action_30 @ GHC.Base.String)) -}
d4f9475bf7703f913756b0417be68747
  alex_action_1 :: GHC.Integer.Type.Integer
  {- Strictness: b -}
b78ce4ec99bb183891c4f5a2f1ac7e0a
  alex_action_10 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m9,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenComma p) -}
c2403c69445cf6e8b6f65443e876ba3b
  alex_action_11 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m10,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenHash p) -}
d936c6ff1a11634682386e2caacc031d
  alex_action_12 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m11,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenGE p) -}
15504cc499c4b3ab9717723e3a6fe365
  alex_action_13 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m12,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenLE p) -}
c38bb7609585ee907d98d96cccf56be0
  alex_action_14 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m13,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenGT p) -}
9d4d742083ce8f3f2cbf8f830475c42b
  alex_action_15 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m14,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenLT p) -}
fc1a09bcf37139130d9dba2e0286910a
  alex_action_16 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m15,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenEQ p) -}
a46b93ae37f42020495359dd06290e73
  alex_action_17 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m16,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenNEQ p) -}
8e8f0f38194b8b74aeff1694378328de
  alex_action_18 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m17,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenPlus p) -}
188493403523e20404f799f6235dd79d
  alex_action_19 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m18,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenMinus p) -}
c6a321c68ce2e53bd6a888a08bcb4a8f
  alex_action_2 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m1,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenLParen p) -}
6fb9744bf8dc243e317e75a2800d160d
  alex_action_20 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m19,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenTimes p) -}
645f6ad6f1fd77b1d0d8055e496b1d21
  alex_action_21 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m20,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenBool p) -}
d859fa8b324d11cf846cca433c0ad1b7
  alex_action_22 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m21,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenInt p) -}
8da6a748a4e853103df1cadd84fffe73
  alex_action_23 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m22,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenVec p) -}
b820695a1b1d4a2f0ef9c871aeb3d5c1
  alex_action_24 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m23,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenTrue p) -}
c5cbccbb1270aefb2081c2d03d49b65e
  alex_action_25 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m24,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenFalse p) -}
c7e02c039c3f9aa42a81cdb2df724ba4
  alex_action_26 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m25,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenNot p) -}
4b1fe1a0864d99297ac87796ff2d52f7
  alex_action_27 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m26,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenAnd p) -}
742490bc3933add368e06866d96b6f53
  alex_action_28 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m27,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenOr p) -}
d9d201deedf5a6ff64536708dabe7b4d
  alex_action_29 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m28,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenFun p) -}
0d6795ee1a10a142d1863dae9f903320
  alex_action_3 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m2,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenRParen p) -}
682bcec24e8028867950ee588ef450fb
  alex_action_30 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m29,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenIf p) -}
65ed10a3e262e92e024a513788e43b2c
  alex_action_31 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m30,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenElse p) -}
8c17f98b8b857bcde05ae497fa08c2d8
  alex_action_32 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m31,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenWhile p) -}
f9d6f363a8d51c9c4d016c36e2eec16f
  alex_action_33 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m32,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenReturn p) -}
cfbd0fd15b0c84be41b36af8a2b40c9a
  alex_action_34 :: Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m33,
     Unfolding: InlineRule (2, True, False)
                (\ p :: Lexer.AlexPosn s :: GHC.Base.String ->
                 Lexer.TokenId (p, s)) -}
7adf2614cd9e5275b918bbb5d8cc802f
  alex_action_35 :: Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token
  {- Arity: 2, Strictness: <L,U><L,U>m34, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Lexer.AlexPosn w1 :: GHC.Base.String ->
                 Lexer.TokenNum
                   (w,
                    case Text.Read.readEither6
                           @ GHC.Integer.Type.Integer
                           (Text.ParserCombinators.ReadP.run
                              @ GHC.Integer.Type.Integer
                              Lexer.alex_action_39
                              w1) of wild {
                      [] -> Lexer.alex_action_38
                      : x ds
                      -> case ds of wild1 {
                           [] -> x : ipv ipv1 -> Lexer.alex_action_1 } })) -}
5c9f6f6c1b5157080d17a89b6b00f0ee
  alex_action_38 :: GHC.Integer.Type.Integer
  {- Strictness: b -}
2f0b80299977bfbc71d6caa31c0f0338
  alex_action_39 ::
    Text.ParserCombinators.ReadP.P GHC.Integer.Type.Integer
  {- Unfolding: ((GHC.Read.$fReadInteger3
                    GHC.Read.$fReadInteger_$sconvertInt
                    Text.ParserCombinators.ReadPrec.minPrec)
                   `cast`
                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0]
                      <GHC.Integer.Type.Integer>_R)
                   @ GHC.Integer.Type.Integer
                   (Text.Read.readEither5 @ GHC.Integer.Type.Integer)) -}
7259904f67c0091fa877fd43f732e092
  alex_action_4 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m3,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenLBrack p) -}
4b48a5fae4b8f1f409ebfd321c9fe3fa
  alex_action_5 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m4,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenRBrack p) -}
c87d8021494ab23bbb10bf05da809ed9
  alex_action_6 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m5,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenLBrace p) -}
4fe34547ef86fd730c7d5b742292e1df
  alex_action_7 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m6,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenRBrace p) -}
833dadce4b6803d278fef1161385eb42
  alex_action_8 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m7,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenAssign p) -}
71a49a10237758857202b28321eb1fc9
  alex_action_9 :: Lexer.AlexPosn -> t -> Lexer.Token
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m8,
     Unfolding: InlineRule (2, True, True)
                (\ @ t p :: Lexer.AlexPosn s :: t -> Lexer.TokenColon p) -}
8694bcf9777e7a4a750fa28483075c2a
  alex_base :: Lexer.AlexAddr
  {- HasNoCafRefs, Strictness: m -}
ddc03d23d4dd22d672c67632773a222e
  alex_check :: Lexer.AlexAddr
  {- HasNoCafRefs, Strictness: m -}
2110bd4e3d38eee442f1351178a7e4f6
  alex_deflt :: Lexer.AlexAddr
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lexer.AlexA#
                   "\\255\\255\\255\\255\\255\\255\\255\\255\f\NUL\f\NUL\ENQ\NUL\ENQ\NUL\\255\\255\\255\\255\SO\NUL\SO\NUL\SO\NUL\\255\\255\SO\NUL\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255"#) -}
3ab7be5867624e09020a0b5c9aa9828e
  alex_scan_tkn ::
    t
    -> t1
    -> GHC.Prim.Int#
    -> Lexer.AlexInput
    -> GHC.Prim.Int#
    -> Lexer.AlexLastAcc
         (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token)
    -> (Lexer.AlexLastAcc
          (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token),
        Lexer.AlexInput)
  {- Arity: 6,
     Strictness: <L,A><L,A><L,U><S(LLSL),1*U(U(U,U,U),U,U,U)><L,U><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (6, True, False)
                (\ @ t
                   @ t1
                   w :: t
                   w1 :: t1
                   w2 :: GHC.Prim.Int#
                   w3 :: Lexer.AlexInput
                   w4 :: GHC.Prim.Int#
                   w5 :: Lexer.AlexLastAcc
                           (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) ->
                 case w3 of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 case Lexer.$walex_scan_tkn
                        @ t
                        @ t1
                        w2
                        ww1
                        ww2
                        ww3
                        ww4
                        w4
                        w5 of ww5 { (#,#) ww6 ww7 ->
                 (ww6, ww7) } }) -}
92e26dd6c6427c61c87df63e7e5e4d4f
  alex_tab_size :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8) -}
7159c63cbd556c26eee6c9a66749057d
  alex_table :: Lexer.AlexAddr
  {- HasNoCafRefs, Strictness: m -}
1eed09712748c379b548092203178fbd
  ignorePendingBytes :: Lexer.AlexInput -> Lexer.AlexInput
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: (Lexer.AlexPosn,
                          GHC.Types.Char,
                          [Lexer.Byte],
                          GHC.Base.String) ->
                 case ds of wild { (,,,) p c ps s ->
                 (p, c, GHC.Types.[] @ Lexer.Byte, s) }) -}
c30411c3c32da06a83e81e8bec4062bd
  quickIndex ::
    GHC.Arr.Array
      GHC.Types.Int
      (Lexer.AlexAcc
         (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) GHC.Prim.Any)
    -> GHC.Types.Int
    -> Lexer.AlexAcc
         (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) GHC.Prim.Any
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SSLL),1*U(1*H,1*H,A,U)><S,1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: GHC.Arr.Array
                            GHC.Types.Int
                            (Lexer.AlexAcc
                               (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) GHC.Prim.Any)
                   eta1 :: GHC.Types.Int ->
                 case eta of wild { GHC.Arr.Array ds2 ds3 dt arr# ->
                 case eta1 of wild1 { GHC.Types.I# i# ->
                 case GHC.Prim.indexArray#
                        @ (Lexer.AlexAcc
                             (Lexer.AlexPosn -> GHC.Base.String -> Lexer.Token) GHC.Prim.Any)
                        arr#
                        i# of ds4 { (##) ipv ->
                 ipv } } }) -}
f1bb11bbd67c1fdf5f19bc01cac9d62a
  tokenize :: GHC.Base.String -> [Lexer.Token]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True) Lexer.alexScanTokens -}
527edf4c69a01437d285887569e84c0b
  utf8Encode :: GHC.Types.Char -> [GHC.Word.Word8]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Types.Char ->
                 case x of wild { GHC.Types.C# c# ->
                 GHC.Base.build
                   @ GHC.Word.Word8
                   (\ @ b1
                      c :: GHC.Word.Word8 -> b1 -> b1[OneShot]
                      n :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Int
                      @ b1
                      (GHC.Base.mapFB
                         @ GHC.Word.Word8
                         @ b1
                         @ GHC.Types.Int
                         c
                         Lexer.alexGetByte2)
                      n
                      (Lexer.utf8Encode1 (GHC.Types.I# (GHC.Prim.ord# c#)))) }) -}
8bad039a151d17d5657a4c32e9256a82
  utf8Encode1 :: GHC.Types.Int -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww1 127) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.<=# ww1 2047) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<=# ww1 65535) of wild2 {
                             GHC.Types.False
                             -> GHC.Types.:
                                  @ GHC.Types.Int
                                  (GHC.Types.I#
                                     (GHC.Prim.+# 240 (GHC.Prim.uncheckedIShiftRA# ww1 18)))
                                  (GHC.Types.:
                                     @ GHC.Types.Int
                                     (GHC.Types.I#
                                        (GHC.Prim.+#
                                           128
                                           (GHC.Prim.andI#
                                              (GHC.Prim.uncheckedIShiftRA# ww1 12)
                                              63)))
                                     (GHC.Types.:
                                        @ GHC.Types.Int
                                        (GHC.Types.I#
                                           (GHC.Prim.+#
                                              128
                                              (GHC.Prim.andI#
                                                 (GHC.Prim.uncheckedIShiftRA# ww1 6)
                                                 63)))
                                        (GHC.Types.:
                                           @ GHC.Types.Int
                                           (GHC.Types.I# (GHC.Prim.+# 128 (GHC.Prim.andI# ww1 63)))
                                           (GHC.Types.[] @ GHC.Types.Int))))
                             GHC.Types.True
                             -> GHC.Types.:
                                  @ GHC.Types.Int
                                  (GHC.Types.I#
                                     (GHC.Prim.+# 224 (GHC.Prim.uncheckedIShiftRA# ww1 12)))
                                  (GHC.Types.:
                                     @ GHC.Types.Int
                                     (GHC.Types.I#
                                        (GHC.Prim.+#
                                           128
                                           (GHC.Prim.andI# (GHC.Prim.uncheckedIShiftRA# ww1 6) 63)))
                                     (GHC.Types.:
                                        @ GHC.Types.Int
                                        (GHC.Types.I# (GHC.Prim.+# 128 (GHC.Prim.andI# ww1 63)))
                                        (GHC.Types.[] @ GHC.Types.Int))) }
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Int
                             (GHC.Types.I#
                                (GHC.Prim.+# 192 (GHC.Prim.uncheckedIShiftRA# ww1 6)))
                             (GHC.Types.:
                                @ GHC.Types.Int
                                (GHC.Types.I# (GHC.Prim.+# 128 (GHC.Prim.andI# ww1 63)))
                                (GHC.Types.[] @ GHC.Types.Int)) }
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Int
                        (GHC.Types.I# ww1)
                        (GHC.Types.[] @ GHC.Types.Int) } }) -}
instance GHC.Classes.Eq [Lexer.AlexPosn] = Lexer.$fEqAlexPosn
instance GHC.Classes.Eq [Lexer.Token] = Lexer.$fEqToken
instance GHC.Base.Functor [Lexer.AlexLastAcc]
  = Lexer.$fFunctorAlexLastAcc
instance GHC.Show.Show [Lexer.AlexPosn] = Lexer.$fShowAlexPosn
instance GHC.Show.Show [Lexer.Token] = Lexer.$fShowToken
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

